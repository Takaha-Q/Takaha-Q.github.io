<!DOCTYPE html>
<!-- 基準URI -->
<base href="https://takaha-q.github.io/">
<!-- スタイルシート -->
<link rel="stylesheet" href="Sytle001.css" type="text/css">
<!-- スクリプト -->
<!-- タイトル表示 -->
<script src="MakeTitle.js" type="text/javascript"></script>
<!-- 目次表示 -->
<script src="MakeToc_L.js" type="text/javascript"></script>
<!-- ページタイトル(ページ内表示) -->
<span id="title"></span>
<!-- リンク(ホームに戻る) -->
<a href="index.html">ホームに戻る</a>
<!-- 出典・関連ページ -->
</div>
</details>

<!-- 関連ページ -->
<details><summary class=link>関連 :</summary>
<div class=pre><a href="TIPS/02_プログラミング言語/01_C・C%2B%2B/継承 (Inheritance).html">継承 (Inheritance)</a>
<a href="TIPS/02_プログラミング言語/01_C・C%2B%2B/仮想関数 (Virtual Function).html">仮想関数 (Virtual Function)</a>
<a href="TIPS/02_プログラミング言語/01_C・C%2B%2B/委譲コンストラクタと継承コンストラクタ.html">委譲コンストラクタと継承コンストラクタ</a>


</div>
</details>

<!-- 目次 -->
<h5>目次 :</h5>
<div id="toc"></div>
<hr>
<!-- 本文ここから -->

<h2>親(継承元)クラスを指定して関数を呼び出す</h2>
通常、クラス内でメンバ関数を呼び出す場合は、( this ポインタによって関連付けられる)自身のメンバを呼ぶこととなる。<br>
(自身ではなく)親クラスの関数を呼び出したい場合は、 <b>スコープ解決演算子 ("::") を用いて親クラスの名前を指定する</b> 。<br>
⇒ オーバーライドした仮想関数中で、オーバーライド元の関数を呼び出すなど。<br>
このとき呼び出せる関数は<b> private 修飾されたもの以外</b>に限られる。

<div class="code">
<cmt>// 親クラス</cmt>
<kwd>class</kwd> C_Parent
{
<kwd>public</kwd>:
    <kwd>virtual</kwd> <kwd>void</kwd> Hoge();
}

<cmt>// 子クラス</cmt>
<kwd>class</kwd> C_Child : <kwd>public</kwd> C_Parent
{
<kwd>private</kwd>:
    <kwd>void</kwd> Fuga();
}

<cmt>// Hoge() のオーバーライド</cmt>
<kwd>void</kwd> C_Child::Hoge()
{
    <cmt>// 親 (C_Parent) の Hoge() をコール</cmt>
    C_Parent::Hoge();
}

<kwd>void</kwd> C_Child::Fuga()
{
    <cmt>// 自身 (C_Child) の Hoge() をコール</cmt>
    Hoge();
}
</p>
<h2>余談</h2>
JavaやC#では親クラスの名前を明示的に指定する必要は無く、super (Java)、base (C#)を用いる。<br>
これは両者では多重継承が認められておらず、親クラスが一意に定まるため。<br>

